const ARRAY_TYPE=typeof Float32Array!=="undefined"?Float32Array:Array;const EPSILON=1e-6;const create=()=>{let e=new ARRAY_TYPE(16);if(ARRAY_TYPE!==Float32Array){e[1]=0;e[2]=0;e[3]=0;e[4]=0;e[6]=0;e[7]=0;e[8]=0;e[9]=0;e[11]=0;e[12]=0;e[13]=0;e[14]=0}e[0]=1;e[5]=1;e[10]=1;e[15]=1;return e};const perspective=(e,t,n,r,s)=>{let o=1/Math.tan(t/2);let a;e[0]=o/n;e[1]=0;e[2]=0;e[3]=0;e[4]=0;e[5]=o;e[6]=0;e[7]=0;e[8]=0;e[9]=0;e[11]=-1;e[12]=0;e[13]=0;e[15]=0;if(s!=null&&s!==Infinity){a=1/(r-s);e[10]=(s+r)*a;e[14]=2*s*r*a}else{e[10]=-1;e[14]=-2*r}return e};const identity=e=>{e[0]=1;e[1]=0;e[2]=0;e[3]=0;e[4]=0;e[5]=1;e[6]=0;e[7]=0;e[8]=0;e[9]=0;e[10]=1;e[11]=0;e[12]=0;e[13]=0;e[14]=0;e[15]=1;return e};const lookAt=(e,t,n,r)=>{let s,o,a,c,i,f,u,l,p,E;let h=t[0];let m=t[1];let d=t[2];let T=r[0];let g=r[1];let _=r[2];let R=n[0];let P=n[1];let x=n[2];if(Math.abs(h-R)<EPSILON&&Math.abs(m-P)<EPSILON&&Math.abs(d-x)<EPSILON){return identity(e)}u=h-R;l=m-P;p=d-x;E=1/Math.hypot(u,l,p);u*=E;l*=E;p*=E;s=g*p-_*l;o=_*u-T*p;a=T*l-g*u;E=Math.hypot(s,o,a);if(!E){s=0;o=0;a=0}else{E=1/E;s*=E;o*=E;a*=E}c=l*a-p*o;i=p*s-u*a;f=u*o-l*s;E=Math.hypot(c,i,f);if(!E){c=0;i=0;f=0}else{E=1/E;c*=E;i*=E;f*=E}e[0]=s;e[1]=c;e[2]=u;e[3]=0;e[4]=o;e[5]=i;e[6]=l;e[7]=0;e[8]=a;e[9]=f;e[10]=p;e[11]=0;e[12]=-(s*h+o*m+a*d);e[13]=-(c*h+i*m+f*d);e[14]=-(u*h+l*m+p*d);e[15]=1;return e};const SchemaTypes={vec4:"vec4",vec3:"vec3",vec2:"vec2",int:"int",float:"float",mat4:"mat4",mat3:"mat3",mat2:"mat2",tex2D:"tex2D",texCube:"texCube",index:"index"};const GLEnums={triangles:"triangles",lines:"lines",rgb:"rgb",rgba:"rgba",srgb:"srgb"};const RendererConfig={contextAttributes:{},clearColor:[0,0,0,1],bufferChunkSize:100*1024,offscreenTextureSize:512,extensions:["EXT_shader_texture_lod","EXT_SRGB","OES_standard_derivatives","OES_element_index_uint"]};const push=(e,t)=>{e[e.length]=t};const concat=(e,t)=>{const n=e.length;for(let r=0;r<t.length;r++){e[n+r]=t[r]}};const isFirst=(e,t)=>{for(let n=e.length-1;n>=0;n--){if(e[n]!==t[n])return false}return true};const isPowerOf2=e=>(e&e-1)===0;const mapValue=(e,t)=>Object.keys(e).reduce((n,r)=>({...n,[r]:t(e,r)}),{});const bufferTypeSize=()=>4;const getBufferKeys=e=>Object.keys(e.buffers);const getIndexKey=(e,t)=>e.find(e=>t.buffers[e].type===SchemaTypes.index);const createRelatedElementsGroup=(e,t)=>{const n=e.map(()=>[]);for(let r=0;r<e.length;r++){const s=e[r];const{name:o}=s.constructor;for(let e=0;e<t.length;e++){if(!t[e].plugins[o])continue;push(n[r],t[e])}}return n};const getSharedProps=(e,t)=>{const{buffers:n}=e.propSchema;const r=Object.keys(n).filter(e=>n[e].type!==SchemaTypes.index);const s=e.propsByElement(t.state);for(let e=0;e<r.length;e++){s[r[e]]=[]}return s};const getNumComponents=e=>{const{vec2:t,vec3:n,vec4:r,float:s}=SchemaTypes;const o={[t]:2,[n]:3,[r]:4,[s]:1};return o[e]};const joinBufferProps=(e,t,n,r=0)=>{if(!t.length)return{};const{propSchema:s,shareMap:o}=e;const{name:a}=e.constructor;const c=mapValue(t[0],()=>[]);const i=getBufferKeys(s);const f=getIndexKey(i,s);let u=r;for(let e=0;e<t.length;e++){const r=t[e];const l=n[e];const p=o.get(l);const E=p?p.indexMap[a][0]:u;const h=[];for(let e=0;e<r[f].length;e++){push(h,r[f][e]+E)}l.bufferPropsMap[a]={...r,[f]:h};i.forEach(e=>{concat(c[e],l.bufferPropsMap[a][e])});const m=i[0];const{n:d,type:T}=s.buffers[m];const g=d||getNumComponents(T);const _=r[m].length/g;l.indexMap[a]=[u,u+_];u=u+_}return c};const alignBufferProps=(e,t,n,r)=>{const{propSchema:s}=e;const{name:o}=e.constructor;const a=getBufferKeys(s);const c=getIndexKey(a,s);if(!n||!c||!n.bufferPropsMap[o])return joinBufferProps(e,t,r,0);const i=n.indexMap[o][1];return joinBufferProps(e,t,r,i)};const bufferPropOffset=(e,t,n)=>{let r=0;for(let s=0;s<e.length;s++){if(!e[s].plugins[t])continue;r+=e[s].bufferPropsMap[t][n].length}return r};const getLastRelatedElement=(e,t)=>{for(let n=e.length-1;n>=0;n--){if(e[n].plugins[t])return e[n]}};const divideUploadKeys=(e,t,n,r)=>{const{propSchema:s}=e;const{name:o}=e.constructor;const a=getBufferKeys(s);const c=[];const i=[];for(let e=0;e<a.length;e++){const s=a[e];const f=bufferTypeSize();const u=bufferPropOffset(t,o,s)*f;const l=n[s].length*f;const p=u+l;p<r?push(i,s):push(c,s)}return[c,i]};const allocateBufferSizes=(e,t,n,r)=>{const{propSchema:s,bufferSizes:o}=e;for(let e=0;e<t.length;e++){const s=t[e];const a=bufferTypeSize();const c=n[s].length*a;o[s]+=Math.max(r,c)}};const divideElementsByCode=(e,t)=>{const n={};for(let r=0;r<e.length;r++){const s=e[r];if(!s.plugins[t])continue;const o=s.codeMap[t];n[o]?push(n[o],s):n[o]=[s]}return Object.keys(n).map(e=>n[e])};let i=66;const generateChar=()=>{const e=String.fromCharCode(i);i++;return e};const updateElementProps=(e,t,n,r,s)=>{const{propSchema:o,textureMap:a,elementCodeMap:c}=t;const i=Object.keys(o.textures);const f=Object.keys(o.uniforms);for(let u=0;u<n.length;u++){const l=n[u];const{name:p}=t.constructor;const E=t.propsByElement(l.state);i.forEach((t,n)=>{if(o.textures[t].source)return;const c=E[t];if(!!c&&!a.get(c)){const i=s(e,r,c,o.textures[t],n);a.set(c,i)}});let h="";const m=f.map(e=>{if(!E[e])return"";return E[e].map?E[e].map(e=>e.toFixed(3)).join(""):E[e].toFixed(3)}).join("");h+=m;i.forEach(e=>{if(o.textures[e].source)return;let t=c.get(E[e]);if(!t)t=generateChar();c.set(E[e],t);h+=t});l.codeMap[p]=h||"A"}};const updateEnvProps=(e,t,n,r,s)=>{const{propSchema:o,textureMap:a}=t;const c=t.propsByEnv(n);Object.keys(c).forEach((t,n)=>{if(!o.textures[t]||o.textures[t].source)return;n++;const i=c[t];if(!!i&&!a.get(i)){const c=s(e,r,i,o.textures[t],n);a.set(i,c)}})};const updateCodeMap=(e,t,n,r,s,o)=>{updateElementProps(e,t,n,s,o);updateEnvProps(e,t,r,s,o)};const divideDrawGroups=(e,t)=>{const{propSchema:n}=e;const{name:r}=e.constructor;const s=divideElementsByCode(t,r);const o=Object.keys(n.buffers).find(e=>n.buffers[e].type===SchemaTypes.index);const a=[];let c=0;for(let e=0;e<s.length;e++){const t=s[e];const n=t.map(e=>e.bufferPropsMap[r][o].length).reduce((e,t)=>e+t,0);const i={offset:c,elements:t,length:n};c+=n;push(a,i)}e.drawGroups=a};const getTextureBySchema=(e,t,n,r,s)=>{if(!n.textures[e].source)return r.get(t);const o=s.find(t=>{return t.constructor.name===n.textures[e].source.name});return o.offscreenTexture};const getWebGLInstance=(e,t)=>e.getContext("webgl",t);const getExtensions=(e,t)=>{const n={};t.extensions.forEach(t=>{n[t]=e.getExtension(t)});return n};const compileShader=(e,t,n)=>{const r=e.createShader(t);e.shaderSource(r,n);e.compileShader(r);if(!e.getShaderParameter(r,e.COMPILE_STATUS)){console.error("Error compiling shaders",e.getShaderInfoLog(r));e.deleteShader(r);return null}return r};const initShader=(e,t,n,r)=>{const s=Object.keys(t).reduce((e,n)=>e+`#define ${n} ${t[n]}\n`,"");const o=compileShader(e,e.VERTEX_SHADER,s+n);const a=compileShader(e,e.FRAGMENT_SHADER,s+r);const c=e.createProgram();e.attachShader(c,o);e.attachShader(c,a);e.linkProgram(c);if(!e.getProgramParameter(c,e.LINK_STATUS)){console.error("Failed to init program",e.getProgramInfoLog(c));return null}return c};const initProgramInfo=(e,t,n,r,s)=>{const o=initShader(e,t,r,s);const a=mapValue(n.buffers,(t,n)=>({type:t[n].type,location:e.getAttribLocation(o,n)}));const c=mapValue({...n.uniforms,...n.textures},(t,n)=>({type:t[n].type,location:e.getUniformLocation(o,n)}));return{program:o,attributes:a,uniforms:c}};const initBuffers=(e,t,n)=>{const r={};const s=getBufferKeys(t);s.forEach(s=>{const o=e.createBuffer();const a=t.buffers[s].type===SchemaTypes.index;const c=a?e.ELEMENT_ARRAY_BUFFER:e.ARRAY_BUFFER;e.bindBuffer(c,o);e.bufferData(c,n,e.STATIC_DRAW);r[s]=o});return r};const initFramebufferObject=(e,t,n)=>{let r,s,o;const a=()=>{if(r)e.deleteFramebuffer(r);if(s)e.deleteTexture(s);if(o)e.deleteRenderbuffer(o);return null};r=e.createFramebuffer();if(!r){console.error("Failed to create framebuffer object");return a()}s=e.createTexture();if(!s){console.error("Failed to create texture object");return a()}o=e.createRenderbuffer();if(!o){console.error("Failed to create renderbuffer object");return a()}if(t.cube){const t=new Uint8Array(n*n*4);e.bindTexture(e.TEXTURE_CUBE_MAP,s);for(let r=0;r<6;r++){const s=e.TEXTURE_CUBE_MAP_POSITIVE_X+r;e.texImage2D(s,0,e.RGBA,n,n,0,e.RGBA,e.UNSIGNED_BYTE,t)}e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE);e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE);e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MIN_FILTER,e.LINEAR_MIPMAP_LINEAR);e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MAG_FILTER,e.LINEAR);e.generateMipmap(e.TEXTURE_CUBE_MAP)}else{e.bindTexture(e.TEXTURE_2D,s);e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n,n,0,e.RGBA,e.UNSIGNED_BYTE,null);e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST);e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST);e.bindRenderbuffer(e.RENDERBUFFER,o);e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_COMPONENT16,n,n)}return{fbo:r,rbo:o,texture:s}};const uploadFullBuffers=(e,t,n,r)=>{if(!n.length)return;const{buffers:s,bufferSizes:o,propSchema:a}=t;const{name:c}=t.constructor;const i=n.reduce((e,t)=>({...e,[t]:[]}),{});for(let e=0;e<r.length;e++){const t=r[e].bufferPropsMap[c];if(!t)continue;for(let e=0;e<n.length;e++){const r=n[e];concat(i[r],t[r])}}n.forEach(t=>{const n=a.buffers[t].type===SchemaTypes.index;if(n)return;const r=i[t];const c=new Float32Array(r);e.bindBuffer(e.ARRAY_BUFFER,s[t]);e.bufferData(e.ARRAY_BUFFER,o[t],e.STATIC_DRAW);e.bufferData(e.ARRAY_BUFFER,c,e.STATIC_DRAW)})};const uploadSubBuffers=(e,t,n,r,s)=>{const{buffers:o,propSchema:a}=t;const{name:c}=t.constructor;r.forEach(t=>{const r=a.buffers[t].type===SchemaTypes.index;if(r)return;const i=n[t];const f=new Float32Array(i);const u=bufferPropOffset(s,c,t);e.bindBuffer(e.ARRAY_BUFFER,o[t]);e.bufferSubData(e.ARRAY_BUFFER,u*4,f)})};const upload2DTexture=(e,t,n,r)=>{const s=e.createTexture();e.activeTexture(e.TEXTURE0+r);e.bindTexture(e.TEXTURE_2D,s);if(n.flip)e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,true);const o=new Uint8Array([0,0,0,255]);const a=e.RGBA;const c=t instanceof Uint8Array||t instanceof Uint32Array;if(n.source){e.texImage2D(e.TEXTURE_2D,0,a,1,1,0,a,e.UNSIGNED_BYTE,o)}else if(c){const[r,s]=[n.width,n.height];e.texImage2D(e.TEXTURE_2D,0,e.RGBA,r,s,0,e.RGBA,e.UNSIGNED_BYTE,t)}else{e.texImage2D(e.TEXTURE_2D,0,a,a,e.UNSIGNED_BYTE,t)}if(t&&isPowerOf2(t.width)&&isPowerOf2(t.height)&&t.nodeName!=="VIDEO"){e.generateMipmap(e.TEXTURE_2D);if(!n.repeat){e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE);e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)}else{e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.REPEAT);e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.REPEAT)}}else{e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE);e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE);e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR)}return s};const uploadCubeTexture=(e,t,n,r,s)=>{const{level:o,images:a}=n;const c=[e.TEXTURE_CUBE_MAP_POSITIVE_X,e.TEXTURE_CUBE_MAP_NEGATIVE_X,e.TEXTURE_CUBE_MAP_POSITIVE_Y,e.TEXTURE_CUBE_MAP_NEGATIVE_Y,e.TEXTURE_CUBE_MAP_POSITIVE_Z,e.TEXTURE_CUBE_MAP_NEGATIVE_Z];const i=e.createTexture();e.activeTexture(e.TEXTURE0+s);e.bindTexture(e.TEXTURE_CUBE_MAP,i);e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE);e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE);if(o<2){e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MIN_FILTER,e.LINEAR);e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MAG_FILTER,e.LINEAR)}else{e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MIN_FILTER,e.LINEAR_MIPMAP_LINEAR);e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MAG_FILTER,e.LINEAR)}e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!!r.flip);const f=new Uint8Array([0,0,0,255]);let u=0;for(let n=0;n<c.length;n++){for(let s=0;s<=o;s++){const o=c[n];const i=t.EXT_SRGB.SRGB_EXT;r.source?e.texImage2D(e.TEXTURE_2D,0,i,1,1,0,i,e.UNSIGNED_BYTE,f):e.texImage2D(o,s,i,i,e.UNSIGNED_BYTE,a[u]);u++}}return i};const uploadTexture=(e,t,n,r,s)=>{return r.type===SchemaTypes.texCube?uploadCubeTexture(e,t,n,r,s):upload2DTexture(e,n,r,s)};const clearBuffers=(e,t)=>{const{bufferSizes:n,buffers:r,propSchema:s}=t;const o=getBufferKeys(s);o.forEach(t=>{const o=s.buffers[t].type===SchemaTypes.index;const a=o?e.ELEMENT_ARRAY_BUFFER:e.ARRAY_BUFFER;e.bindBuffer(a,r[t]);e.bufferData(a,n[t],e.STATIC_DRAW)})};const resetBeforeDraw=(e,t)=>{const[n,r,s,o]=t;e.viewport(0,0,e.canvas.width,e.canvas.height);e.clearColor(n,r,s,o);e.clearDepth(1);e.disable(e.BLEND);e.enable(e.DEPTH_TEST);e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT)};const uploadIndexBuffer=(e,t)=>{const{buffers:n,propSchema:r,drawGroups:s}=t;const{name:o}=t.constructor;const a=getBufferKeys(r);const c=getIndexKey(a,r);const i=[];for(let e=0;e<s.length;e++){for(let t=0;t<s[e].elements.length;t++){const n=s[e].elements[t];concat(i,n.bufferPropsMap[o][c])}}const f=new Uint32Array(i);e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n[c]);e.bufferData(e.ELEMENT_ARRAY_BUFFER,f,e.STATIC_DRAW)};const draw=(e,t,n,r,s,o)=>{const{programInfo:a,propSchema:c,buffers:i,textureMap:f,mode:u}=t;const l=getBufferKeys(c);e.useProgram(a.program);let p=null;l.forEach(t=>{if(c.buffers[t].type===SchemaTypes.index){p=i[t]}else{const{location:n}=a.attributes[t];const{n:r,type:s}=c.buffers[t];const o=r||getNumComponents(s);e.bindBuffer(e.ARRAY_BUFFER,i[t]);e.vertexAttribPointer(n,o,e.FLOAT,false,0,0);e.enableVertexAttribArray(n)}});p&&e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,p);let E=-1;Object.keys(a.uniforms).forEach(t=>{const{location:s,type:o}=a.uniforms[t];const i=r[t];const u={[SchemaTypes.vec4]:()=>e.uniform4fv(s,i),[SchemaTypes.vec3]:()=>e.uniform3fv(s,i),[SchemaTypes.vec2]:()=>e.uniform2fv(s,i),[SchemaTypes.int]:()=>{!i||typeof i==="number"||typeof i==="string"?e.uniform1i(s,i):e.uniform1iv(s,i)},[SchemaTypes.float]:()=>{!i||typeof i==="number"||typeof i==="string"?e.uniform1f(s,i):e.uniform1fv(s,i)},[SchemaTypes.mat4]:()=>e.uniformMatrix4fv(s,false,i),[SchemaTypes.mat3]:()=>e.uniformMatrix3fv(s,false,i),[SchemaTypes.mat2]:()=>e.uniformMatrix2fv(s,false,i),[SchemaTypes.tex2D]:()=>{E++;const r=getTextureBySchema(t,i,c,f,n);if(!r)console.warn(`Missing texture for ${t} at unit ${E}`);e.uniform1i(s,E);e.activeTexture(e.TEXTURE0+E);e.bindTexture(e.TEXTURE_2D,r)},[SchemaTypes.texCube]:()=>{E++;const r=getTextureBySchema(t,i,c,f,n);if(!r)console.warn(`Missing texture for ${t} at unit ${E}`);e.uniform1i(s,E);e.activeTexture(e.TEXTURE0+E);e.bindTexture(e.TEXTURE_CUBE_MAP,r)}};u[o]()});const h=u===GLEnums.triangles?e.TRIANGLES:e.LINES;e.drawElements(h,s,e.UNSIGNED_INT,o*4)};const drawByGroup=(e,t,n,r)=>{const{drawGroups:s}=t;for(let o=0;o<s.length;o++){const{elements:a,length:c,offset:i}=s[o];const f={...t.propsByElement(a[0].state),...t.propsByEnv(r)};draw(e,t,n,f,c,i)}};const defaultGLUtils={getWebGLInstance:getWebGLInstance,getExtensions:getExtensions,initProgramInfo:initProgramInfo,initBuffers:initBuffers,initFramebufferObject:initFramebufferObject,uploadSubBuffers:uploadSubBuffers,uploadFullBuffers:uploadFullBuffers,uploadIndexBuffer:uploadIndexBuffer,clearBuffers:clearBuffers,uploadTexture:uploadTexture,resetBeforeDraw:resetBeforeDraw,drawByGroup:drawByGroup};class Renderer{constructor(e,t=[],n=[],r=RendererConfig,s=defaultGLUtils){this.rendered=false;this.pipelinePlugins=t;this.offscreenPlugins=n;this.envState={};this.config={...RendererConfig,...r};this.elements=[];this.glUtils=s;const{getWebGLInstance:o,getExtensions:a,initProgramInfo:c,initBuffers:i,initFramebufferObject:f}=this.glUtils;const{bufferChunkSize:u}=this.config;const l=e=>{e.propSchema={uniforms:{},buffers:{},textures:{},...e.propSchema};const{defines:t,vertexShader:n,fragmentShader:r,propSchema:s,offscreenSchema:o}=e;e.programInfo=c(this.gl,t,s,n,r);e.buffers=i(this.gl,s,u);e.bufferSizes=getBufferKeys(s).reduce((e,t)=>({...e,[t]:u}),{});if(!e.offscreen)return;const{fbo:a,rbo:l,texture:p}=f(this.gl,o,this.config.offscreenTextureSize);e.fbo=a;e.rbo=l;e.offscreenTexture=p};this.gl=o(e,this.config.contextAttributes);this.extensions=a(this.gl,this.config);this.pipelinePlugins.forEach(l);this.offscreenPlugins.forEach(l)}addElement(e){this.addElements([e])}addElements(e){const{gl:t,extensions:n,config:r,pipelinePlugins:s,offscreenPlugins:o,glUtils:a,envState:c}=this;const i=this.elements;const f=s=>{const o=createRelatedElementsGroup(s,e);for(let e=0;e<s.length;e++){const f=s[e];const{name:u}=f.constructor;const l=o[e];if(!l.length)continue;const p=[...i,...l];const E=[];for(let e=0;e<l.length;e++){const t=f.shareMap.get(l[e]);const n=t?getSharedProps(f,l[e]):f.propsByElement(l[e].state);push(E,n)}const{bufferChunkSize:h}=r;const m=getLastRelatedElement(i,u);const d=alignBufferProps(f,E,m,l);const[T,g]=divideUploadKeys(f,i,d,h);const{uploadSubBuffers:_,uploadFullBuffers:R,uploadIndexBuffer:P,uploadTexture:x}=a;allocateBufferSizes(f,T,d,h);R(t,f,T,p);_(t,f,d,g,i);updateCodeMap(t,f,l,c,n,x);divideDrawGroups(f,p);P(t,f)}};f(s);f(o);concat(i,e)}removeElement(e){this.removeElements([e])}removeElements(e){const{gl:t,glUtils:n,pipelinePlugins:r,offscreenPlugins:s}=this;const o=this.elements.filter(t=>!e.includes(t));if(isFirst(o,this.elements)){for(let e=0;e<r.length;e++){const n=r[e];divideDrawGroups(n,o);uploadIndexBuffer(t,n)}for(let e=0;e<s.length;e++){const n=s[e];divideDrawGroups(n,o);uploadIndexBuffer(t,n)}this.elements=o;return}const{clearBuffers:a}=n;for(let e=0;e<r.length;e++){a(t,r[e])}for(let e=0;e<s.length;e++){a(t,s[e])}this.elements=[];this.addElements(o)}setElementState(e,t=(e=>{})){const{gl:n,extensions:r,elements:s,pipelinePlugins:o,offscreenPlugins:a,glUtils:c}=this;const{uploadTexture:i}=c;t(e.state);for(let t=0;t<o.length;t++){const a=o[t];updateElementProps(n,a,[e],r,i);divideDrawGroups(a,s);uploadIndexBuffer(n,a)}for(let t=0;t<a.length;t++){const o=a[t];updateElementProps(n,o,[e],r,i);divideDrawGroups(o,s);uploadIndexBuffer(n,o)}}setEnvState(e,t){this.envState[e]=t;if(!this.rendered)return;const{gl:n,extensions:r,glUtils:s,envState:o,pipelinePlugins:a,offscreenPlugins:c}=this;const{uploadTexture:i}=s;for(let e=0;e<a.length;e++){const t=a[e];updateEnvProps(n,t,o,r,i)}for(let e=0;e<c.length;e++){const t=c[e];updateEnvProps(n,t,o,r,i)}}shareElementState(e,...t){const n=n=>{for(let r=0;r<n.length;r++){for(let s=0;s<t.length;s++){n[r].shareMap.set(t[s],e)}}};n(this.pipelinePlugins);n(this.offscreenPlugins)}renderPipeline(){const{gl:e,glUtils:t,pipelinePlugins:n,offscreenPlugins:r,envState:s,config:o}=this;const{clearColor:a}=o;const{resetBeforeDraw:c}=t;c(e,a);for(let o=0;o<n.length;o++){const a=n[o];const{drawByGroup:c}=t;if(!a.enable)continue;a.beforeDraw(e);c(e,a,r,s);a.afterDraw(e)}this.rendered=true}renderOffscreen(){}render(){this.renderPipeline()}}class ShadePlugin{constructor(e={}){this.enable=true;this.defines=e;this.programInfo=null;this.vertexShader="";this.fragmentShader="";this.propSchema={buffers:{},uniforms:{},textures:{}};this.elementCodeMap=new Map;this.drawGroups=[];this.buffers={};this.bufferSizes={};this.textureMap=new WeakMap;this.shareMap=new WeakMap;this.mode=GLEnums.triangles;this.offscreen=false;this.offscreenSchema={};this.fbo=null;this.rbo=null;this.offscreenTexture=null}propsByElement(e){return{}}propsByEnv(e){return{}}beforeDraw(e){}afterDraw(e){}}const createElement=(e,...t)=>({state:e,plugins:t.reduce((e,t)=>({...e,[t.name]:t}),{}),codeMap:{},indexMap:{},bufferPropsMap:{}});class Basic3DRenderer extends Renderer{constructor(...e){super(...e);this.setCamera();this.setPerspective()}setCamera(e=[0,0,0],t=[0,0,0],n=[0,1,0]){const r=create();lookAt(r,e,t,n);this.setEnvState("cameraEye",e);this.setEnvState("cameraCenter",t);this.setEnvState("cameraUp",n);this.setEnvState("camera",r)}setPerspective(e=Math.PI/6,t=.1,n=1e3){const{canvas:r}=this.gl;const s=r.clientWidth/r.clientHeight;const o=create();perspective(o,e,s,t,n);this.setEnvState("perspective",o);this.setEnvState("perspectiveFOV",e);this.setEnvState("perspectiveNear",t);this.setEnvState("perspectiveFar",n)}}const push$1=(e,t)=>{e[e.length]=t};const vertexShader=`\nprecision highp float;\n\nattribute vec4 pos;\nattribute vec4 center;\nattribute vec2 texCoord;\n\nuniform mat4 viewMat;\nuniform mat4 projectionMat;\nuniform mat4 rotateMat;\nuniform float iTime;\n\nvarying vec2 vTexCoord;\n\nconst vec3 camera = vec3(0, 0, 1);\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main() {\n  vec3 dir = normalize(center.xyz * rand(center.xy) - camera);\n  vec3 translatedPos = pos.xyz + dir * iTime;\n  vec4 mvpPos = projectionMat * viewMat * vec4(translatedPos, 1);\n\n  vTexCoord = texCoord;\n  gl_Position = mvpPos;\n}\n`;const fragmentShader=`\nprecision highp float;\nuniform sampler2D img;\nvarying highp vec2 vTexCoord;\n\nvoid main() {\n  gl_FragColor = texture2D(img, vTexCoord);\n}\n`;class PiecePlugin extends ShadePlugin{constructor(){super();const{vec2:e,vec4:t,mat4:n,tex2D:r,float:s,index:o}=SchemaTypes;this.vertexShader=vertexShader;this.fragmentShader=fragmentShader;this.propSchema={buffers:{pos:{type:t,n:2},center:{type:t,n:2},texCoord:{type:e},index:{type:o}},uniforms:{iTime:{type:s},viewMat:{type:n},projectionMat:{type:n}},textures:{img:{type:r,flip:true}}}}propsByElement(e){const{img:t,n:n=1}=e;const[r,s,o,a]=[[],[],[],[]];for(let e=0;e<n;e++){for(let t=0;t<n;t++){const[c,i]=[e/n,(e+1)/n];const[f,u]=[t/n,(t+1)/n];const[l,p]=[c+i/2,f+u/2];const E=.5;push$1(r,c-E);push$1(r,f-E);push$1(r,i-E);push$1(r,f-E);push$1(r,i-E);push$1(r,u-E);push$1(r,c-E);push$1(r,u-E);push$1(o,c);push$1(o,f);push$1(o,i);push$1(o,f);push$1(o,i);push$1(o,u);push$1(o,c);push$1(o,u);push$1(s,l-E);push$1(s,p-E);push$1(s,l-E);push$1(s,p-E);push$1(s,l-E);push$1(s,p-E);push$1(s,l-E);push$1(s,p-E);const h=(e*n+t)*4;push$1(a,h);push$1(a,h+1);push$1(a,h+2);push$1(a,h);push$1(a,h+2);push$1(a,h+3)}}return{pos:r,center:s,texCoord:o,index:a,img:t}}propsByEnv(e){const{iTime:t,camera:n,perspective:r}=e;return{iTime:t,viewMat:n,projectionMat:r}}}const createPieceElement=e=>createElement(e,PiecePlugin);const loadImage=e=>new Promise(t=>{const n=new Image;n.onload=(()=>t(n));n.src=e});const loadImages=e=>Promise.all(e.map(loadImage));const canvas=document.getElementById("gl-canvas");canvas.height=document.body.offsetHeight;canvas.width=document.body.offsetWidth;const piecePlugin=new PiecePlugin;const renderer=new Basic3DRenderer(canvas,[piecePlugin]);renderer.setCamera([0,0,10]);renderer.setEnvState("iTime",0);const n=parseInt(window.location.hash.replace("#",""))||150;const urls=["/images/gundam.jpg"];loadImages(urls).then(([e])=>{const t=createPieceElement({img:e,n:n});renderer.addElement(t);const r=()=>{renderer.render();window.requestAnimationFrame(r)};r()});const btn=document.getElementById("go");btn.addEventListener("click",()=>{let e=0;const t=()=>{e+=.1;renderer.setEnvState("iTime",e);window.requestAnimationFrame(t)};t()});